package main

/*
go工具

go工具将不同种类的工具集合并为一个命名集。它是一个包管理器（类似于apt或rpm），它可以查询包的作者，计算它们的依赖关系，
从远程版本控制系统下载它们。它是一个构建系统，可计算文件依赖，调用编译器、汇编器和链接器，尽管它没有标准的UNIXmake命令完备。
*/

/*
工作空间的组织

大部分用户必须进行的唯一的配置是GOPATH环境变量，它指定工作空间的根。
当需要切换到不同的工作空间时，更新GOPATH变量的值即可。

GOPATH有三个子目录：
1. src子目录包含源文件。每一个包放在一个目录中，该目录相对于$GOPATH/src的名字是包的导入路径。
2. pkg子目录是构建工具存储编译后的包的位置
3. bin子目录放置像helloworld这样的可执行程序。


第二个环境变量是GOROOT，它指定Go发行版的根目录，其中提供所有标准库的包。
GOROOT下面的目录结构类似于GOPATH，这样fmt包的源代码放在$GOROOT/src/fmt目录中。
用户无须设置GOROOT，因为默认情况下go工具使用它的安装路径。

go env命令输出与工具链相关的已经设置有效值的环境变量及其所设置值，还会输出未设置有效值的环境变量及其默认值。
GOOS指定目标操作系统（例如，android、linux、darwin或者windows）。
GOARCH指定目标处理器架构，比如amd64、386或arm。
*/

/*
包的构建

go get命令可以下载单一的包，也可以使用...符号来下载子树或仓库。
如果你指定-u开关，go get将确保它访问的所有包（包括它们的依赖性）更新到最新版本，然后再构建和按照。
如果没有这个标记，已经存在于本地的包不会更新。

go build命令编译每一个命令行参数中的包。如果包是一个库，结果会被舍弃；对于没有编译错误的包几乎不做检查。
如果包的名字是main，go build调用链接器在当前目录中创建可执行程序，可执行程序的名字取自包的导入路径的最后一段。

go install命令和go build非常相似，区别是它会保存每一个包的编译代码和命令，而不是把它们丢弃。
编译后的包保存在$GOPATH/pkg目录中，它对应于存放源文件的src目录，可执行的命令保存在$GOPATH/bin目录中。
（许多用户将$GOPATH/bin加入它们的可执行搜索路径中。）
这样，go build和go install对于没有改变的包和命令不需要重新编译，从而使后续的构建更加快速。
惯例上，go build -i可以将包安装在独立于构建目标的地方。

因为编译包根据操作系统平台和CPU体系结构不同而不同，所以go install将保存它们的目录命名为
与GOOS和GOARCH变量的值相关。

为了处理底层的可移植性问题或为重要的例程提供优化版本，有一些包需要为特定的平台或者处理器编译不同版本的代
码。如果一个文件名包含操作系统或处理器体系结构名字（如net_linux.go或asm_amd64.s），
go工具只会在构建指定规格的目标文件的时候才进行编译。叫作构建标签的特殊注释，提供更细粒度的控制。
例如，如果一个文件包含下面的注释(不带反引号`):
`// +build linux darwin`
注释在包的声明之前（它是文档注释），go build只会在构建Linux或Mac OS X系统应用的时候才会对它进行编译。
下面的注释指出任何时候都不要编译这个文件(不带反引号`)：
`// +build ignore`

*/

/*
包的文档化

Go风格强烈鼓励有良好的包API文档。每一个导出的包成员的声明以及包声明自身应该立刻使用注释来描述它的目的和用途。
Go文档注释总是完整的语句，使用声明的包名作为开头的第一句注释通常是总结。函数参数和其他的标识符无须括起来或者特别
标注。例如：
// Fprintf formats according to a format specifier and writes to w.
// It returns the number of bytes written and any write error encountered.
func Fprintf(w io.Writer, format string, a ...interface{}) (int, error)

go doc工具输出在命令行上指定的内容的声明和整个文档注释，如：
`go doc time`
*/

/*
内部包

这是包用来封装Go程序最重要的机制。
没有导出的标识符只能在同一个包内访问，导出的标识符可以在世界任何地方访问。

有时，有一个中间地带是很有帮助的，这种方式定义标识符可以被一个小的可信任的包集合访问，但不是所有人可以访问。
例如，当我们将一个大包分解为多个可托管的小包时，我们不想对其他的包显露这些包之间的关系。
或者我们想在不进行导出的情况下，在项目的一些包中间共享一些工具函数。
或者我们只是想试验一个新的包，而不是永久地提交给它的API，可以通过加上一个允许访问的有限客户列表来实现。

为了解决这些需求，go build工具会特殊对待导入路径中包含路径片段internal的情况。这些包叫内部包。
内部包只能被另一个包导入，这个包位于以internal目录的父目录为根目录的树中。
例如，给定下面的包net/http/internal/chunked，它可以从net/http/httputil或net/http导入，
但是不能从net/url进行导入。然而，net/url可以导入net/http/httputil。
*/

/*
包的查询

go list工具上报可用包的信息。通过最简单的形式，go list判断一个包是否存在于工作空间中，如果存在输出它的导入路径。
go list命令的参数可以包含“...”通配符，它用来匹配包的导入路径中的任意子串。
可以使用它枚举一个Go工作空间中的所有包。
`go list ...`
或者一个指定的子树中的所有包：
`go list foo/...`
或者一个具体的主题：
`go list ...xml...`

go list命令获取每一个包的完整元数据，而不仅仅是导入路径，
并且提供各种对于用户或者其他工具可访问的格式。
-json标记使go list以JSON格式输出每一个包的完整记录。
`go list -json hash`

-f标记可以让用户通过text/template包提供的模板语言来定制输出格式。
`go list -f '{{join Deps " "}}' strconv`
*/

/*
变量的生命周期

变量的声明周期指的是程序在运行期间变量有效存在的时间间隔。
*/
package main

/*
对于包一级的变量来说，它们的声明周期和整个程序的生命周期是一致的（相当于全局变量）。
*/
var LifeTime = "global"

/*
对于局部变量来说，变量的生命周期是动态的：
每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后该变量的存储空间可能被回收。
函数的参数变量和返回值变量都是局部变量，它们在函数每次被调用时创建。
*/
func local_var(count int) int {
	z := 0

	// 在每次循环开始时会创建变i，然后在每次循环迭代中创建临时变量x和y
	for i := 0; i < 5; i++ {
		x := 2 * i
		y := 3 * i
		z = x + y
	}

	return z
}

// TODO: 是否可以用汇编查看函数返回值创建的局部变量

/*
GO语言的垃圾收集器是如何直到某个变量是何时可以被回收呢？
基本思路是，从包级变量和每个当前正在运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说这个变量是不可达的，可以标记为可回收的。
因为一个变量是否可回收取决于它是否可达，因此一个循环迭代内部的局部变量可的生命周期可能超过其作用域。同时，局部变量可能在函数返回后依然存在。
*/

// 局部变量的逃逸
func local_var_escape(count int) *int {
	z := 0

	// 在每次循环开始时会创建变i，然后在每次循环迭代中创建临时变量x和y
	for i := 0; i < 5; i++ {
		x := 2 * i
		y := 3 * i
		z += x + y
	}

	// z 虽然是函数内部创建的局部变量，但是因为返回了z变量的地址供外部引用，所以z将会在编译器产生函数逃逸，将会在堆上分配内存
	return &z
}

// 编译器会自动选择在栈上或者堆上分配内存空间，这和选择使用var还是new()的方式声明变量无关。
func var_escape() *int {
	// x 虽然是函数内的局部变量，但是因为返回了变量的地址，所以它的生命周期不会因为出了函数的作用域就终止
	x := 1

	/*
		y 虽然是用new分配的，但是因为只是在函数内部使用，所以*y没有从函数中逃逸。
		编译器可以选择在栈上分配*y的存储空间；也可以选择在堆上分配空间，然后由GO语言的GC回收器回收这个变量的内存空间。
		虽然在任何时候不需要为写正确的代码而考虑变量的逃逸行为，但要记住，逃逸的变量需要额外分配内存，同时对性能的优化也会产生细微影响。
	*/
	y := new(int)
	print(y)

	return &x
}

package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
)

/*
错误

对于大部分函数而言，永远无法确保能否成功运行。这是因为错误的原因超出了程序员的控制。
在Go语言的错误处理中，错误时软件包API和应用程序用户界面的一个重要组成部分，程序运行失败仅仅被认为是几个预期的结果之一。

对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。
如果导致失败的原因只有一个，额外的返回值可能是一个bool值，通常被命名为ok。比如，cache.Lookup失败的唯一原因是key不存在，
那么代码可以按照下面的方式组织：
value, ok := cache.Lookup(key)
if !ok {
	...
}
通常，导致失败的原因不止一种，尤其是对于I/O操作而言，用户需要更多的错误信息。因此，额外的返回值不再是简单布尔类型，而是error类型。
error类型是Go语言的内置错误类型。通常，函数返回error时，其它返回值是未定义的，这些未定义的返回值应该被忽略。

在Go语言中，函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（exception），这使得Go有别于那些将函数失败看作是异常的语言。
虽然Go有各种异常机制，但这些机制仅被用在处理那些未被预料的错误，即bug，而不是处理那些在健壮程序中应该避免的错误。

Go这样设计的原因是对于应该在控制流程中处理的错误而言，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。
正因为如此，Go用控制流机制（如if和else）响应错误，这使得编码人员更多的关注错误处理。
*/

/*
错误的处理策略

常用的五种错误处理策略：
1. 传播错误
这也是最常用的方式。错误沿着调用链条传播。
当错误最终被顶层函数处理时，错误信息应该提供清晰的从原因到结果的因果链。
由于错误信息经常是以链式组合在一起的，所以错误信息中尽量避免大写和换行符。

2. 重试策略
如果错误的发生是偶然性的，或者由不可预知的问题导致的。我们可以选择重新尝试失败的操作。
再重试时，需要限制重试的时间间隔或重试的次数，以防无限制重试。

3. 如果错误导致无法继续，则输出错误信息并结束程序。
需要注意的是，这种策略只因该在main函数中执行。
对于库函数来说，应该仅向上传播错误，除非该错误意味着程序内部包含着不一致性，即遇到了bug，才能在库函数中结束程序。

4. 有时我们只需要输出错误信息就行了，不需要中断运行

5. 我们可以直接忽略错误

在Go中，错误处理有一套独特的编码风格。检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。
如果某个错误会导致函数的返回，那么成功的逻辑不应该放在else语句中，而是应该放在函数体中。

Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，然后是函数的实际逻辑。
*/

/*
文件结尾错误（EOF）

io包保证任何由文件结束引起的读取失败都返回同一个错误----io.EOF。调用者只需要通过简单的比较就能检查到这个错误。
*/
func io_eof() error {
	in := bufio.NewReader(os.Stdin)
	for {
		r, _, err := in.ReadRune()
		if err == io.EOF {
			break // finished reading
		}
		if err != nil {
			return fmt.Errorf("read failed:%v", err)
		}
		fmt.Println(r)
	}

	return nil
}

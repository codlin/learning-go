package main

import "fmt"

/*
GO语言提供的整数数据类型包括：
int8, int16, int32, int64, uint8, uint16, uint32, uint64, int, uint
其中int和uint和CPU平台相关，不同的平台对应的大小不一样。
Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。
byte是uint8的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。
uintptr是一种无符号的整数类型，没有指定具体的大小但是足以容纳指针。
不同类型之间需要显式的转换操作。
*/

/*
GO语言有符号数采用2的补码形式，最高位为1代表负数。
假设有符号整数的位数为w，因为有符号数的补码把最高位作为符号位，所以其权重为-K<w-1>*2^(w-1)，其中K<w-1>为w-1位的数值。
补码求值的计算公式为：
x = -K<w-1> * 2^(w-1) + Σ K<i> * 2^i (i=[0, w-2], K<w-1>为w-1位上的值， K<i>为第i位上的值)
补码形式的有符号数的正负值不对称，因为最高位为1其余位为0的这个表示被最小负数（即权重，本应该是-0）占了，所以能表示的最大正数少了1。
例如，8位有符号数的补码表示范围位[-128, 127]

如果采用二进制反码表示，除了最高位有效权为-K<w-1>*(2^(w-1)-1)外，其它和二进制补码一致。即负数反码的最高位权值比补码的大1。
所以，对于给定负数补码，如果看做是反码的话，其值为：补码值 + 1。
反过来，如果给定一个负数，其反码表示形式为：补码 - 1。
例如：
对于最大8位的给定二进制原码11111000，如果看做是补码，其值位-8，如果看做是反码，其值为-7。
对于最大8位的整型数-8，其补码为11111000，那么其反码为11110111。
由反码的表示形式看，反码是对称的，但是和补码比0变成了+0和-0两个值。
例如，8位有符号数的反码表示范围位[-127, 127]，但是有两个0。

采用补码形式，可以避免正0和负0的问题，对数值的计算产生了很大的便利（具体参见CSAPP第二章）。

总结：
对于正数，其补码T、反码O，和原码B一致；
对于负数，其补码为对应的正数取反加1，其反码为补码+1；
负数的补码形式求值，快捷方法是取反加1，得到正数的值，然后再加上负号。
*/
func overflow() {
	var u uint8 = 255
	fmt.Println(u, u+1, u*u)

	var i int8 = 127
	fmt.Println(i, i+1, i*i)
}

/*
GO语言提供了算术运算符：+ - * / %
其中+ 、‐ 、* 和/ 可以适用于整数、浮点数和复数，但是取模运算符%仅用于整数间的运算。
在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此‐5%3 和‐5%‐3 结果都是2。
除法运算符 / 的行为则依赖于操作数是否为全为整数，比如5.0/4.0 的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数。
*/
func math() {
	// %取模运算符的符号和被取模数的符号总是一致的
	fmt.Println(-5%3 == -5%-3)

	// GO语言的整数除法向0方向截断，不会向最近的值舍入（round to nearest）
	fmt.Println(5 / 4)
	fmt.Println(-5 / 4)

	fmt.Println(5 / 3)
	fmt.Println(-5 / 3)

	fmt.Println(5 / 2)
	fmt.Println(-5 / 2)
	fmt.Println()

	// 浮点数的摄入不是向0方向，而是向最近值舍入
	fmt.Println(5.0 / 4.0)
	fmt.Println(-5.0 / 4.0)

	fmt.Println(5.0 / 3.0)
	fmt.Println(-5.0 / 3.0)

	fmt.Println(5.0 / 2.7)
	fmt.Println(-5.0 / 2.7)

	fmt.Println(5.0 / 2.0)
	fmt.Println(-5.0 / 2.0)
}

/*
GO语言提供了以下逻辑运算符：
> 大于
< 小于
>=大于等于
<=小于等于
== 等于
!= 不等
&& 逻辑与
|| 逻辑或
*/
func logic() {
	a, b, c, d := 1, 2, false, true
	if a > b {
		c = true
	}

	if c && d {
		fmt.Println(true)
	}

	if c || d {
		fmt.Println(true)
	}
}

/*
GO语言还提供了以下的bit位操作运算符，前面4个操作符不区分有符号还是无符号数：
&  位运算 AND
|  位运算 OR
^  位运算 XOR
&^ 位清空 AND NOT
<< 左移
>> 右移
*/
func bit() {
	a := 0xFFFFD8D8
	mask := 0x0000ABAB
	fmt.Printf("%#x\n", a&mask)       // 0x00008888
	fmt.Printf("%#x\n", a|mask)       // 0xFFFFFBFB
	fmt.Printf("%#x\n", a^mask)       // 0x00007373
	fmt.Printf("%#x\n", a&^mask)      // 0x00005050
	fmt.Printf("%#x\n", int32(a<<18)) // 0x63600000
	fmt.Printf("%#x\n", a<<18)        // 0x3ffff63600000
	fmt.Printf("%#x\n", a>>8)         // 0xFFFFFFD8
}

func main() {
	overflow()
	math()
	logic()
	bit()
}

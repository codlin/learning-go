package main

import "fmt"

/*
GO语言提供的整数数据类型包括：
int8, int16, int32, int64, uint8, uint16, uint32, uint64, int, uint
其中int和uint和CPU平台相关，不同的平台对应的大小不一样。
Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点。
byte是uint8的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。
uintptr是一种无符号的整数类型，没有指定具体的大小但是足以容纳指针。
不同类型之间需要显式的转换操作。
*/

/*
GO语言有符号数采用2的补码形式，最高位为1代表负数。
假设有符号整数的位数为w，因为有符号数的补码把最高位作为符号位，所以其权重为-K<w-1>*2^(w-1)，其中K<w-1>为w-1位的数值。
补码求值的计算公式为：
x = -K<w-1> * 2^(w-1) + Σ K<i> * 2^i (i=[0, w-2], K<w-1>为w-1位上的值， K<i>为第i位上的值)
补码形式的有符号数的正负值不对称，因为最高位为1其余位为0的这个表示被最小负数（即权重，本应该是-0）占了，所以能表示的最大正数少了1。
例如，8位有符号数的补码表示范围位[-128, 127]

如果采用二进制反码表示，除了最高位有效权为-K<w-1>*(2^(w-1)-1)外，其它和二进制补码一致。即负数反码的最高位权值比补码的大1。
所以，对于给定负数补码，如果看做是反码的话，其值为：补码值 + 1。
反过来，如果给定一个负数，其反码表示形式为：补码 - 1。
例如：
对于最大8位的给定二进制原码11111000，如果看做是补码，其值位-8，如果看做是反码，其值为-7。
对于最大8位的整型数-8，其补码为11111000，那么其反码为11110111。
由反码的表示形式看，反码是对称的，但是和补码比0变成了+0和-0两个值。
例如，8位有符号数的反码表示范围位[-127, 127]，但是有两个0。

采用补码形式，可以避免正0和负0的问题，对数值的计算产生了很大的便利（具体参见CSAPP第二章）。

总结：
对于正数，其补码T、反码O，和原码B一致；
对于负数，其补码为对应的正数取反加1，其反码为补码+1；
负数的补码形式求值，快捷方法是取反加1，得到正数的值，然后再加上负号。
*/
func overflow() {
	var u uint8 = 255
	fmt.Println(u, u+1, u*u)

	var i int8 = 127
	fmt.Println(i, i+1, i*i)
}

/*
GO语言提供了算术运算符：+ - * / %
其中+ 、‐ 、* 和/ 可以适用于整数、浮点数和复数，但是取模运算符%仅用于整数间的运算。
在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此‐5%3 和‐5%‐3 结果都是2。
除法运算符 / 的行为则依赖于操作数是否为全为整数，比如5.0/4.0 的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数。
*/
func math() {
	// %取模运算符的符号和被取模数的符号总是一致的
	fmt.Println(-5%3 == -5%-3)

	// GO语言的整数除法向0方向截断，不会向最近的值舍入（round to nearest）
	fmt.Println(5 / 4)
	fmt.Println(-5 / 4)

	fmt.Println(5 / 3)
	fmt.Println(-5 / 3)

	fmt.Println(5 / 2)
	fmt.Println(-5 / 2)
	fmt.Println()

	// 浮点数的摄入不是向0方向，而是向最近值舍入
	fmt.Println(5.0 / 4.0)
	fmt.Println(-5.0 / 4.0)

	fmt.Println(5.0 / 3.0)
	fmt.Println(-5.0 / 3.0)

	fmt.Println(5.0 / 2.7)
	fmt.Println(-5.0 / 2.7)

	fmt.Println(5.0 / 2.0)
	fmt.Println(-5.0 / 2.0)
}

/*
GO语言提供了以下逻辑运算符：
> 大于
< 小于
>=大于等于
<=小于等于
== 等于
!= 不等
&& 逻辑与
|| 逻辑或
*/
func logic() {
	a, b, c, d := 1, 2, false, true
	if a > b {
		c = true
	}

	if c && d {
		fmt.Println(true)
	}

	if c || d {
		fmt.Println(true)
	}
}

/*
GO语言还提供了以下的bit位操作运算符，前面4个操作符不区分有符号还是无符号数：
&  位运算 AND
|  位运算 OR
^  位运算 XOR
&^ 位清空 AND NOT
<< 左移
>> 右移
*/
func bit() {
	a := 0xFFFFD8D8
	mask := 0x0000ABAB
	fmt.Printf("%#x\n", a&mask)       // 0x00008888
	fmt.Printf("%#x\n", a|mask)       // 0xFFFFFBFB
	fmt.Printf("%#x\n", a^mask)       // 0x00007373
	fmt.Printf("%#x\n", a&^mask)      // 0x00005050
	fmt.Printf("%#x\n", int32(a<<18)) // 0x63600000
	fmt.Printf("%#x\n", a<<18)        // 0x3ffff63600000
	fmt.Printf("%#x\n", a>>8)         // 0xFFFFFFD8
}

/*
1. 左移1位相当于乘以2，右移1位相当于除以2
2. %b可以打印二级制格式的数字，其中%08b表示打印至少8位字符宽度，不足的前缀部分用0补充
3. 有符号数右移时最高位用符号位补充，当为正数时用0补充，负数时用1补充。
   无符号数右移时最高位用0补充。
   因为这个原因，当您将整数视为位模式时，使用无符号算术非常重要。
*/
func bit2() {
	/* 左移1位相当于乘以2，右移1位相当于除以2 */
	var x uint8 = 1<<1 | 1<<5
	var y uint8 = 1<<1 | 1<<2

	/* %b可以打印二级制格式的数字，其中%08b表示打印至少8位字符宽度，不足的前缀部分用0补充 */
	fmt.Printf("%08b\n", x) // "00100010"
	fmt.Printf("%08b\n", y) // "00000110"

	fmt.Printf("%08b\n", x&y)
	fmt.Printf("%08b\n", x|y)
	fmt.Printf("%08b\n", x^y)
	fmt.Printf("%08b\n", x&^y)

	// 测试8位数字里面的1所在位置
	for i := uint(0); i < 8; i++ {
		if x&(1<<i) != 0 { //membership test
			fmt.Println(i)
		}
	}

	/* 整数左移时低位用0补充。
	有符号数右移时最高位用符号位补充，当为正数时用0补充，负数时用1补充。
	无符号数右移时最高位用0补充。
	因为这个原因，当您将整数视为位模式时，使用无符号算术非常重要。
	*/
	fmt.Printf("%08b\n", x<<1)
	fmt.Printf("%08b\n", x>>1)

}

/*
尽管GO提供了无符号数和运算，但是我们更趋向于使用有符号int的形式，即使数值本身不可能出现负数值。
就像数组的长度那样，虽然使用uint无符号类型似乎是一个更合理的选择。事实上，内置的len函数返回的是一个有符号的int。
*/
func trend_to_int() {
	medals := []string{"gold", "silver", "bronze"}
	// 如果len返回的是无符号类型，对这个程序来说就是灾难。
	for i := len(medals) - 1; i >= 0; i-- {
		fmt.Println(medals[i]) // "bronze", "silver", "gold"
	}
	/* 出于这个原因，无符号数倾向于仅在需要其位运算符或特殊算术运算符时使用，例如在实现位集、解析二进制文件格式或用于散列和加密时。
	它们通常不仅用于非负数场景。
	*/
}

/*
显式类型转换 Explicit conversion

一般来说，需要一个显式的转换将一个值从一种类型传化到另一种类型，并且算术和逻辑运算的二元操作必须是相同的类型。
对应任意类型T，都有一个对应的类型转换操作T(x)，用于将x转换为类型T（如果T是指针类型，需要加括号，比如(* int)(p)，因为不加括号变成了*操作）。
只有当两个类型的底层类型相同时才允许这种转换操作，或者两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。
*/
func explicit_conv() {
	var apples int32 = 1
	var oranges int16 = 2
	// var compote = apples + oranges // 编译错误
	var compote = apples + int32(oranges)
	fmt.Println(compote)
}

/* 整数的格式化
当使用fmt包格式化输出是，可以使用%b, %o, %d, %x参数控制输出的格式
%b 二进制
%o 八进制
%d 十进制
%x 十六进制
%后的#指明打印时在打印输出时生成0、0x或0X前缀
%后可以使用`[序数]`来指明打印第几个参数的值，序数从第1个开始，譬如%[1]d
*/
func format() {
	var a int16 = 12345
	fmt.Printf("%b, 0%o, %d, 0x%x\n", a, a, a, a)

	/* %后可以使用[序数]来指明打印第几个参数的值，序数从第1个开始 */
	fmt.Printf("%[1]b, 0%[1]o, %[1]d, 0x%[1]x\n", a)

	/* %0后加数字可以打印数值的位宽，宽度不够时用0补充。不过不指定0，则用空白填充 */
	fmt.Printf("%016b\n", a)
	fmt.Printf("%16b\n", a)

	/* %后的#指明打印时在打印输出时生成0、0x或0X前缀，该选项不能用于%d */
	o := 0666
	fmt.Printf("%[1]d, %#[1]o, %#[1]o\n", o)

	/* %X以大写方式打印16进制数 */
	x := int64(0xdeedbeef)
	fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)

	/* 字符使用%c打印，或者使用%q打印带单引号的字符 */
	b := 'b'
	fmt.Printf("%[1]c, %[1]q\n", b)
	fmt.Printf("%03[1]c, %03[1]q\n", b)

}

func main() {
	overflow()
	math()
	logic()
	bit()
	bit2()
	trend_to_int()
	explicit_conv()
	format()
}
